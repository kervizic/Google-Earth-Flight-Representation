%Tests et validation de la réalisation
%            Démarche pour tester le produit (manque pas des vols)
%            Un fichier même vol, mais fichiers avec des vols supplémentaires
%            Présentation du rendu
%Améliorations continues : à partir des tests, je repars dans le chapitre précédent (réalisation technique + nouveaux besoins (comparaison FPL//ADSC) ou correction)

\section{Les tests}
Nous avons effectué au cours de ce projet deux types de tests: les tests unitaires et les tests globaux.

    \subsection{Les tests unitaires}
En programmation informatique, le test unitaire est un procédé permettant de s'assurer du fonctionnement correct d'une partie déterminée d'un logiciel ou d'une portion d'un programme (appelée «unité» ou «module»).

On écrit un test pour confronter une réalisation à sa spécification. Le test définit un critère d’arrêt (état ou sorties à l’issue de l’exécution) et permet de statuer sur le succès ou sur l’échec d’une vérification. Grâce à la spécification, on est en mesure de faire correspondre un état d’entrée donné à un résultat ou à une sortie. Le test permet de vérifier que la relation d’entrée - sortie donnée par la spécification est bel et bien réalisée.

Rappel de définitions :
\begin{description}
\item[Test:] il s'agit d'une vérification par exécution.
\item[Vérification:] ce terme est utilisé dans le sens de contrôle d'une partie du logiciel. (Une «unité» peut ici être vue comme «le plus petit élément de spécification à vérifier»)
\end{description}

Il s'agit pour nous de tester un module, indépendamment du reste du programme, ceci afin de s'assurer qu'il répond aux spécifications fonctionnelles et qu'il fonctionne correctement en toutes circonstances.

Mais ces tests ne sufisent pas car il ne donnent pas assez de recule pour visualiser si l'ensemble du programme est fonctionnel. Il nous donne seulement une confirmation théorique.

    \subsection{Les tests globaux}
Comme nous l'avons cité précédement des tests unitaires ne sont pas sufisant dans notre cas. En effet ce projet étant un réél prototype, dans le sens ou rien n'a été effectué de semblable auparavant, les spécifications restent parfois mal déterminées. On pourra citer comme exemple la structure des messages \textsc{Fpl} qui sont cencés avoir toujours la même forme, mais qui se retrouve souvent avec des erreurs dûes à la qualité de transmission.

Ces tests auront donc pour but de valider le fait que toutes les parties développées indépendamment fonctionnent bien ensemble de façon cohérente.

Pour ce faire nous avons passé un grand nombre de fichiers sources à «parsé». Ce qui nous a permis de découvrir tout au long du projet un certain nombre d'erreurs. Nous pourons citer en exemple le fait de prendre en compte le nom de l'avion, aéroport de départ et heure de départ comme identifiant, celui-ci pouvant être le même sur plusieurs jours pour les vols cylciques. Dans ce cas les tests globaux nous ont permis de découvrir l'errure et nous ont permis d'ajouter le jour de départ de l'avion dans l'identifiant afin que chaque identifiant reste bien unique.

\section{La validation}
Chaque fin de cycle de notre méthode de gestion de projet qui est l'Extreme Programing nous amène à une étape de validation. Celle-ci conciste à verifier avec le client que le programme se comporte bien comme il le souhaitait.

Après chaque validation des spécifications sont modifiées car, bien que répondant à leur definition, elles ne répondent pas réelement aux attentes du client. D'autres spécifications sont crées et certaines annulées.

\section{Amélioration continue}
A partir des tests réalisés et de la validation avec le client comme cité précédement nous redéfinissons les besoins ainsi que les spécifications. Cela nous amène donc à revenir au cycle des besoins \nref{besoins} dans notre méthode de gestion de projet \nref{extreme}.

Nous reprenons alors un cycle ce qui nous permettra d'améliorer le programme en continu.


